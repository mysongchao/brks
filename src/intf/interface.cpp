// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TNonblockingServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/protocol/TCompactProtocol.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>


#include "BRKService.h"
#include "Logger.h"
#include "event.h"
#include "events_def.h"
#include "interface.h"

#include <functional>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::concurrency;

using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::brkservice;

#define check_delete(ptr) do { if (ptr) delete ptr; } while(0)

class BRKServiceHandler : virtual public BRKServiceIf {
public:
    BRKServiceHandler(std::function< iEvent* (const iEvent*)>  callback) : callback_(callback) {

    }

    /**
     * 获取验证码
     *
     * @param mobile
     */
    void brk_get_mobile_code( ::brkservice::ApiResult& _return, const std::string& mobile) {
        // Your implementation goes here

        LOG_DEBUG("brk_get_mobile_code.");
        MobileCodeReqEv* ev = new MobileCodeReqEv(mobile);
        CommonRspEv* rsp = dynamic_cast<CommonRspEv *>(callback_(ev));

        common_response_msg_2_result(_return, rsp);
        check_delete(rsp);
    }

    /**
     * 登录
     *
     * @param mobile
     * @param code
     */
    void brk_login( ::brkservice::ApiResult& _return, const std::string& mobile, const std::string& code) {
        // Your implementation goes here
        LOG_DEBUG("brk_login.");

        LoginEv* ev = new LoginEv(mobile, code);
        CommonRspEv* rsp = dynamic_cast<CommonRspEv *>(callback_(ev));

        common_response_msg_2_result(_return, rsp);
        check_delete(rsp);
    }

    /**
     * 充值
     *
     * @param mobile
     * @param amount
     */
    void brk_recharge( ::brkservice::ApiResult& _return, const std::string& mobile, const int32_t amount) {
        // Your implementation goes here
        LOG_DEBUG("brk_recharge, mobile=%s, amount=%d.", mobile.c_str(), amount);

        RechargeEv* ev = new RechargeEv(mobile, amount);
        CommonRspEv* rsp = dynamic_cast<CommonRspEv *>(callback_(ev));

        common_response_msg_2_result(_return, rsp);
        check_delete(rsp);
    }

    /**
     * 查询账户余额
     *
     * @param mobile
     */
    void brk_get_account_balance( ::brkservice::BalanceResult& _return, const std::string& mobile) {
        // Your implementation goes here
        LOG_DEBUG("brk_get_account_balance, mobile=%s.", mobile.c_str());

        GetAccountBalanceEv* ev = new GetAccountBalanceEv(mobile);
        GetAccountBalanceRspEv* rsp = dynamic_cast<GetAccountBalanceRspEv *>(callback_(ev));

        balance_response_msg_2_result(_return, rsp);
        check_delete(rsp);
    }

    /**
     * 查询所有消费记录
     *
     * @param mobile
     */
    void brk_list_account_records( ::brkservice::RecordsResult& _return, const std::string& mobile) {
        // Your implementation goes here
        LOG_DEBUG("brk_list_account_records, mobile=%s.", mobile.c_str());

        ListAccountRecordsReqEv* ev = new ListAccountRecordsReqEv(mobile);
        ListAccountRecordsRspEv* rsp = dynamic_cast<ListAccountRecordsRspEv *>(callback_(ev));

        account_records_response_msg_2_result(_return, rsp);
        check_delete(rsp);
    }

    /**
     * 解锁
     *
     * @param mobile
     * @param bike_code
     */
    void brk_unlock( ::brkservice::ApiResult& _return, const std::string& mobile, const std::string& bike_code) {
        // Your implementation goes here
        LOG_DEBUG("brk_unlock, mobile=%s, bike code = %s.", mobile.c_str(), bike_code.c_str());

        UnlockEv* ev = new UnlockEv(mobile, bike_code);
        CommonRspEv* rsp = dynamic_cast<CommonRspEv *>(callback_(ev));
        common_response_msg_2_result(_return, rsp);

        check_delete(rsp);
    }

    /**
     * 查询用户里程
     *
     * @param mobile
     */
    void brk_list_travel( ::brkservice::TravelResult& _return, const std::string& mobile) {
        // Your implementation goes here
        LOG_DEBUG("brk_list_travel.");

        ListTravelRecordsReqEv* ev = new ListTravelRecordsReqEv(mobile);
        ListTravelRecordsRspEv* rsp = dynamic_cast<ListTravelRecordsRspEv *>(callback_(ev));

        trave_result_response_msg_2_result(_return, rsp);
        check_delete(rsp);
    }

  /**
   * 结束行程
   *
   * @param mobile
   * @param bike_code
   */
    void brk_lock( ::brkservice::TravelResult& _return, const std::string& mobile, const std::string& bike_code) {
        // Your implementation goes here
        LOG_DEBUG("brk_lock, mobile=%s, bike code=%s.", mobile.c_str(), bike_code.c_str());

        LockEv* ev = new LockEv(mobile, bike_code);
        LockResultRspEv* rsp = dynamic_cast<LockResultRspEv *>(callback_(ev));
        lock_response_msg_2_result(_return, rsp);

        check_delete(rsp);
    }
private:
    std::function< iEvent* (const iEvent*)>  callback_;

private:
    void common_response_msg_2_result(ApiResult& result, const CommonRspEv* rsp);
    void balance_response_msg_2_result(BalanceResult& result, const GetAccountBalanceRspEv* rsp);
    void account_records_response_msg_2_result(RecordsResult& result, const ListAccountRecordsRspEv* rsp);
    void lock_response_msg_2_result(TravelResult& result, const LockResultRspEv* rsp);
    void trave_result_response_msg_2_result(TravelResult& result, const ListTravelRecordsRspEv* rsp);
};

void BRKServiceHandler::common_response_msg_2_result(ApiResult& result, const CommonRspEv* rsp){
    if (NULL == rsp){
        result.__set_resultCode(ERRC_METHOD_NOT_ALLOWED);
        result.__set_resultMsg("method not allowed!");
        result.__set_data("");
    }
    else{
        result.__set_resultCode(rsp->get_code());
        result.__set_resultMsg(rsp->get_msg());
        result.__set_data(rsp->get_data());
    }
}

void BRKServiceHandler::balance_response_msg_2_result(BalanceResult& result, const GetAccountBalanceRspEv* rsp)
{
    if (NULL == rsp){
        result.__set_resultCode(ERRC_METHOD_NOT_ALLOWED);
        result.__set_resultMsg("method not allowed!");
        result.__set_balance(0);
        //_return.__set_data("");
    }
    else{
        result.__set_resultCode(rsp->get_code());
        result.__set_resultMsg(rsp->get_msg());
        result.__set_balance(rsp->get_balance());
        //_return.__set_data(rsp->get_data());
    }
    return result;
}

void BRKServiceHandler::lock_response_msg_2_result(TravelResult& result, const LockResultRspEv* rsp)
{
    if (NULL == rsp){
        result.__set_resultCode(ERRC_METHOD_NOT_ALLOWED);
        result.__set_resultMsg("method not allowed!");
        result.__set_data("");
        result.__set_mileage(0);
        result.__set_discharge(0);
        result.__set_calorie(0);
        std::vector<brkservice::TravelRecord> trs;
        result.__set_records(trs);
    }
    else{
        TravelInfo info = rsp->get_travel_info();
        result.__set_resultCode(rsp->get_code());
        result.__set_resultMsg(rsp->get_msg());
        result.__set_data(rsp->get_data());
        result.__set_mileage(info.mileage);
        result.__set_discharge(info.discharge);
        result.__set_calorie(info.calorie);
        std::vector<brkservice::TravelRecord> trs;
        for(auto iter = info.records.begin(); iter != info.records.end(); iter++)
        {
            brkservice::TravelRecord tr;
            tr.__set_startTimeStamp(iter->startTimeStamp);
            tr.__set_duration(iter->duration);
            tr.__set_amount(iter->amount);
            trs.push_back(tr);
        }
        result.__set_records(trs);
    }
    return result;
}

void BRKServiceHandler::account_records_response_msg_2_result(RecordsResult& result, const ListAccountRecordsRspEv* rsp)
{
    if (NULL == rsp){
        result.__set_resultCode(ERRC_METHOD_NOT_ALLOWED);
        result.__set_resultMsg("method not allowed!");
        std::vector<AccountRecords> ars;
        result.__set_records(ars);
    }
    else{
        result.__set_resultCode(rsp->get_code());
        result.__set_resultMsg(rsp->get_msg());
        std::vector<brkservice::AccountRecords> ars;
        std::vector<AccountRecord> rs = rsp->get_records();
        for(auto iter = rs.begin(); iter != rs.end(); iter++)
        {
            brkservice::AccountRecords tr;
            tr.__set_type(iter->type);
            tr.__set_limit(iter->limit);
            tr.__set_timestamp(iter->timestamp);
            ars.push_back(tr);
        }
        result.__set_records(ars);
    }
    return result;
}

void BRKServiceHandler::trave_result_response_msg_2_result(TravelResult& result, const ListTravelRecordsRspEv* rsp)
{
    if (NULL == rsp){
        result.__set_resultCode(ERRC_METHOD_NOT_ALLOWED);
        result.__set_resultMsg("method not allowed!");
        result.__set_mileage(0);
        result.__set_discharge(0);
        result.__set_calorie(0);
        std::vector<brkservice::TravelRecord> trs;
        result.__set_records(trs);
    }
    else{
        TravelInfo info = rsp->get_travel_info();
        result.__set_resultCode(rsp->get_code());
        result.__set_resultMsg(rsp->get_msg());
        result.__set_mileage(info.mileage);
        result.__set_discharge(info.discharge);
        result.__set_calorie(info.calorie);
        std::vector<brkservice::TravelRecord> trs;
        for(auto iter = info.records.begin(); iter != info.records.end(); iter++)
        {
            brkservice::TravelRecord tr;
            tr.__set_startTimeStamp(iter->startTimeStamp);
            tr.__set_duration(iter->duration);
            tr.__set_amount(iter->amount);
            trs.push_back(tr);
        }
        result.__set_records(trs);
    }

    return result;
}

BOOL Interface::start(int port)
{
    LOG_INFO("INTF : try to started thrift service on %d port.", port);

    stdcxx::shared_ptr<BRKServiceHandler> handler(new BRKServiceHandler(callback_));
    stdcxx::shared_ptr<TProcessor> processor(new BRKServiceProcessor(handler));
    stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TCompactProtocolFactory());
    stdcxx::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);

    stdcxx::shared_ptr<transport::TNonblockingServerSocket> socket(new TNonblockingServerSocket(port));

    stdcxx::shared_ptr<PosixThreadFactory> threadFactory = stdcxx::shared_ptr<PosixThreadFactory > (new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();

    thrift_server_ = threadFactory->newThread(stdcxx::shared_ptr<TServer>(new TNonblockingServer(processor, protocolFactory, socket, threadManager)));

    try{
        thrift_server_->start();
    }
    catch (TException e){
        LOG_ERROR("INTF : start thrift service failed with error = %s", e.what());
    	  return FALSE;
    }

    LOG_INFO("INTF : started thrift service on %d port.", port);

    return TRUE;
}

BOOL Interface::close(){
    return TRUE;
}
